## 1 Назначение и классификация операционных систем.
ОС - специализированная прграмма (комплекс программ), предназначенная для эффективного использования всех ресурсов вычислительной системы и обеспечения работоспособности дргуих программ.

Основные функции ОС
- Управление апаратными ресурсами вычислительными системами (абстрация над вычислительной системой для легкого её использования)
- Создание среды для выполнения программ
- Обеспечение интерфейса для взаимодействия с пользователем

ОС поддерживает два режима:
- режим ядра 
- режим пользователя

Классификация ОС по приминению на различном ПО:
- ОС мейнфреймов и суперкомпьютеров
- Серверные ОС
- Многопроцессорные ОС
- ОС персональных компьютеров
- ОС моблиьных устройств
- ОС реального времени

Классификация по типу ядра:
- Монолитное - все функции внутри ядра, но тяжело расширять
- Модульное - разновидность микроялро, пример драйверы
- Микроядро - содержитт только необходимые функции, но надежность меньше и быстродействие
- Наноядро
- Экзоядро
- Гибридное ядро

## 2 Понятие WinAPI и его применение при разработке прикладных программ.

**Кратко: API (интерфейс прикладного программирования) упрощает процесс программирования при создании приложений, абстрагируя базовую реализацию и предоставляя только объекты или действия, необходимые разработчику. Windows API предназначен для создания программистами прикладных программ, т.к. система без возможности разрабатывать под нее приложения скорее всего бесполезна. Иначе бы пришлось самим рисовать формочки, читать с жесткого диска и прочее. Называтся он программным интерфейсом, потому что реализует контракт программирования (как что использовать, что вызывать).**

## 3 Процессы и потоки.

Характеристики процесса
- Представляет отдельный экземпляр исполняющей программы
- Явдяется контейнером для всех ресурсов, относящихся к исполняемой программе (потоки, адресное пространство, дескрипторы)
- Позволяет операционной системе управлять выполнением программы (завершать, выделять ресурсы, изменять приоритеты, обеспечивать изоляцию и защиту)

Варианты **создания** процессов
- Инициализация системы
- Выполнение работающим процессом системного вызова, предназначенного для создания другого процесса
- Запрос пользователя на создание новго процесса
- Инициация пакетного задания

Как могу **завершаться** процессы
- Обычный выход (добровольно)
- Выход при возникновении ошибки (добровольно)
- Возникновение фатальной ошибки (принудительно)
- Уничтожение другим процессом (принудительно)

**Структуры** управления процессом
- Таблица процессов. Одна запись на каждый процесс.
- Блок управления процессом. Process control block (PCB). Описывает свой процесс и его текущее состояние.
- Образ процесса. Process Image. Память выделанная для процесса. То, как программа представлена в **виртуальном адресном пространстве**.

Создание процесса в Windows:
- ОС создает соответсвующие служебные объекты, с помощью которых управляют процессом (объект процесса, объект первичный поток)
    1. Преобразование и проверка приемлимости параметров и флагов
    2. Открытие exe файла и создание объекта раздела
    3. Создание процесса Windows
    4. Создание объекта потока Windows
- Инициализация подсистемы Windows
    5. Выполнение инициализации характерного для подсистемы Windows процесса, запускается после создания данного процесса
    6. Исходный процесс возвращает выполнение исходному коду
- Новый процесс
    7. Заключительная часть инициализации новго процесса и образа
    8. Начало выполнения с точки входа в образ

Создание процесса в Unix
- Родительский PCB создает дочерний PCB копируя себя полностью, кроме PID (адресное пространство дочернего процесса сперва даже хранит код родительского)

**Поток**
Для каждого процесса операционная система создает один главный поток (thread ), который является потоком выполняющихся по очереди команд центрального процессора. При необходимости главный поток может создавать другие потоки, пользуясь для этого программным интерфейсом операционной системы.

## 4 Планирование в системах с одним процессором.

**Планирование** - обеспечение поочередного доступа процессов к одному процессору.

**Планировщик** - отвечающая за это часть операционной системы.

**Алгоритм планирования** - используемый алгоритм для планирования.

## 5 Планирование в многопроцессорных системах.

На однопроцессорной машине планирование одномерно. Единственный вопрос, на который должен быть каждый раз получен ответ, – какой процесс должен быть запущен следующим? На мультипроцессоре планирование двумерно. Планировщик должен решить, какой процесс и на котором центральном процессоре запустить. Это дополнительное измерение существенно усложняет планирование процессов на многопроцессорных машинах. Другой усложняющий фактор состоит в том, что в ряде случаев все процессы являются независимыми, тогда как в других случаях они формируют груп­пы.

### Планирование
* Ведение списка или множества списков для разных приоритетов. Освобождающиеся процессоры выбирают процессы из списка по очереди.
* «умное планирование». Если процесс входит в критическую область, захватывается мьютекс, то он не останавливается по кванту времени, а выполняется до освобождения мьютекса.
* Родственное планирование. По возможности процессы отправляются на обработку к тому процессору, который обрабатывал их до этого.
* Планирование по модели «производитель-потребитель».

## 6 Переключение потоков и краткосрочное планирование.

Планировщик хранит очередь исполняемых потоков для каждого уровня приоритета. Такие потоки называются **готовыми к исполнению (ready threads)**. Когда процессор становится доступным - система выполняет переключение потоков. Шаги в переключении следующие:
1. Сохранить контекст только что завершившегося потока.
2. Поместить только завершившийся поток в конец очереди его приоритета.
3. Найти наивысший приоритет в очереди исполняемых потоков (готовых к исполнению ПЫСЫ такой себе из меня переводчик)
4. Удалить поток из наччала очереди, загрузить его контекст и выполнить его.

Приостановленные и заблокированные потоки не являются готовыми к исполнению.

Наиболее распространненные причины переключения контекста:
- Срез времени, отведенный потоку, истек.
- Поток с более высоким приоритетом стал готовым к исполнению.
- Работающий поток ждёт и ему не нужно процессорное время. (Когда работающему потоку нужно подождать, он отказывается от оставшейся части своего временного интервала.)

Планирование использования процессора применяется в качестве **краткосрочного планирования процессов**. Выбор нового процесса для исполнения оказывает влияние на функционирование системы до наступления очередного аналогичного события, т. е. в течение короткого промежутка времени, чем и обусловлено название этого уровня планирования – краткосрочное.

**Краткосрочное планирование** также известно как планировщик ЦП . Основная цель этого планировщика — повысить производительность системы в соответствии с установленными критериями. Это поможет вам выбрать из группы процессов, которые готовы к выполнению, и выделит ЦП одному из них. Диспетчер передает управление процессором процессу, выбранному краткосрочным планировщиком.
[Источник краткосрочного планировщика, можно найти инфу по дргуим](https://coderlessons.com/tutorials/akademicheskii/osnovy-operatsionnykh-sistem/24-planirovanie-protsessa)

Чтобы переключить потоки, нужно сменить контекст потока и т.д.

Переключение контекста (англ. context switch) - это процесс записи и восстановления состояния процесса или потока таким образом, чтобы в дальнейшем продолжить его выполнение с прерванного места. Этот механизм позволяет нескольким процессам разделить между собой ресурсы одного центрального процессора. Является особенностью многозадачных ОС.

## 7 Приоритеты процессов и потоков.

Потоки планируются для запуска на основе их приоритета планирования. Каждому потоку назначается приоритет планирования. Уровни приоритета находятся в диапазоне от нуля (самый низкий приоритет) до 31 (наивысший приоритет). Только поток нулевой страницы может иметь приоритет, равный нулю. (Поток нулевой страницы — это системный поток, ответственный за обнуление свободных страниц при отсутствии других потоков, которые необходимо выполнить.)

Система рассматривает все потоки с одинаковым приоритетом, равным. Система назначает временные срезы циклическим перебору для всех потоков с наивысшим приоритетом. Если ни один из этих потоков не готов к выполнению, система назначает временные срезы циклическим перебору для всех потоков со следующим высшим приоритетом. Если поток с более высоким приоритетом станет доступным для выполнения, система прекратит выполнение потока с низким приоритетом (не позволяя ему завершить работу с его временным срезом) и назначает полный временной срез для потока с более высоким приоритетом.

Приоритет каждого потока определяется следующими критериями.
- Класс приоритета его процесса
- Уровень приоритета потока в классе приоритета его процесса

Класс приоритета и уровень приоритета объединяются для формирования базового приоритета потока.

Классы приоритетов процессов:
- IDLE_PRIORITY_CLASS
- BELOW_NORMAL_PRIORITY_CLASS
- NORMAL_PRIORITY_CLASS
- ABOVE_NORMAL_PRIORITY_CLASS
- HIGH_PRIORITY_CLASS
- REALTIME_PRIORITY_CLASS

Уровни приоритета потоков:
- THREAD_PRIORITY_IDLE
- THREAD_PRIORITY_LOWEST
- THREAD_PRIORITY_BELOW_NORMAL
- THREAD_PRIORITY_NORMAL
- THREAD_PRIORITY_ABOVE_NORMAL
- THREAD_PRIORITY_HIGHEST
- THREAD_PRIORITY_TIME_CRITICAL

Использование класса HIGH_PRIORITY_CLASS ограничено процессами, которые должны завершаться за короткое время, чтобы не вызвать сбойной ситуации.

Большинство процессов запускается в рамках класса с нормальным приоритетом. Нормальный приоритет означает, что процесс не требует какого-либо специального внимания со стороны операционной системы.

И наконец, процессы с фоновым приоритетом запускаются лишь в том случае, если в очереди Диспетчера задач нет других процессов. Обычные виды приложений, использующие такой приоритет, — это программы сохранения экрана и системные агенты

## 8 Синхронизация, механизмы синхронизации.

Синхронизация процессов — это механизм, позволяющий обеспечить целостность какого-либо ресурса (файл, данные в памяти), когда он используется несколькими процессами или потоками в случайном порядке. Для синхронизации процессов и потоков используются семафоры, мьютексы и критические секции. 

**Критическая секция** - область доступа к данным, к которым потенциально могут обратиться одновременно несколько процессов.
**Взаимное исключение** - блокировка критической секции, когда он занята уже одним потоком.

**Семафо́р** — примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить две атомарные операции: увеличение и уменьшение значения на единицу, при этом операция уменьшения для нулевого значения счётчика является блокирующейся (То есть семафор допускает процесс в критичискую секцию после чего уменьшает счетчик, соотвественно на нуле блокирует доступ в критическую секцию).

**Мьютекс** - реализует взаимное исключение. Его основная задача - блокировать все потоки, которые пытаются получить доступ к коду, когда этот код уже выполняет некоторый поток.

## 9 Виртуальное адресное пространство процесса.
Для каждого процесса создается изолированное виртуальное адресное пространство. ОС загружает **образ (см. билет 3, струткура процесса)** программы в виртуальное адресное пространство.

Адресное пространство для каждого процесса является закрытым и не может быть доступно другим процессам, если он не является общим.

Виртуальный адрес не представляет фактическое физическое расположение объекта в памяти; Вместо этого система ведет таблицу страниц для каждого процесса, который представляет собой внутреннюю структуру данных, используемую для преобразования виртуальных адресов в соответствующие физические адреса. Каждый раз, когда поток ссылается на адрес, система преобразует виртуальный адрес в физический адрес.

## 10 Страничная адресация и работа файла подкачки.

Страничная адресация памяти представляет собой механизм управления памятью, позволяющий разрешить задачу повышения эффективности процессов обмена информацией между уровнями иерархической памяти.

Основная идея страничной адресации состоит в разбиении всей памяти на блоки одинаковой длины, называемые страницами. Размер страниц обычно равен целой степени 2 (например, 4K или 1M).

Линейный адрес может не совпадать с физическим адресом, эту страничную трансляцию выполняет **блок управления памятью**. Блок управления памятью использует **таблицу страниц**, в которой хранится соотношение виртуальных страниц к блокам физической памяти. Для обращение к области памяти используется два числа: номер страницы и отступ внутри страницы.

Преимущества:
* При этом для программиста память остается линейной, хотя линейные адреса могут быть разбросаны по разным физическим адресам.
* Легче избавиться от фрагментации памяти.
* Виртуальная память дешевая, можно выделять гигабайты памяти, однако пока они не используются, реальной взаимосвязи с физической памяти нет. Т.е. резервирование не связывает с физическими страницами.
* Страничная трансляция не совпадает с физическими, поэтому программы изолированы друг от друга. (хотя есть исключение CopyOnWrite)
* OS в том числе защищает саму себя.

Используется специальная структура - страничный каталог. Линейный адрес состоит из 3 частей : [10 бит, Индекс каталога][10, Индекс страницы][12, Смещение]. 12 бит - 4 Кб - размер страницы.


## 11 Управление памятью в системах Windows (динамическая память).


Динамическое распределение памяти — способ выделения оперативной памяти компьютера для объектов в программе, при котором выделение памяти под объект осуществляется во время выполнения программы.

При динамическом распределении памяти объекты размещаются в т. н. «куче» (англ. heap): при конструировании объекта указывается размер запрашиваемой под объект памяти, и, в случае успеха, выделенная область памяти, условно говоря, «изымается» из «кучи», становясь недоступной при последующих операциях выделения памяти. Противоположная по смыслу операция — освобождение занятой ранее под какой-либо объект памяти: освобождаемая память, также условно говоря, возвращается в «кучу» и становится доступной при дальнейших операциях выделения памяти.

По мере создания в программе новых объектов количество доступной памяти уменьшается. Отсюда вытекает необходимость постоянно освобождать ранее выделенную память. В идеальной ситуации программа должна полностью освободить всю память, которая потребовалась для работы. По аналогии с этим, каждая подпрограмма (процедура или функция) должна обеспечить освобождение всей памяти, выделенной в ходе её выполнения. Неправильное управление памятью приводит к т.н. «утечкам» памяти, когда выделенная память не освобождается. Многократные утечки памяти могут привести к исчерпанию всей оперативной памяти и нарушить работу операционной системы.

Другая проблема — это проблема фрагментации памяти. Выделение памяти происходит блоками — непрерывными фрагментами оперативной памяти (таким образом, каждый блок — это несколько идущих подряд байт). В какой-то момент в куче попросту может не оказаться блока подходящего размера и, даже если свободная память достаточна для размещения объекта, операция выделения памяти окончится неудачей.

Для управления динамическим распределением памяти используется «сборщик мусора» — программный объект, который следит за выделением памяти и обеспечивает её своевременное освобождение. Сборщик мусора также следит за тем, чтобы свободные блоки имели максимальный размер, и, при необходимости, осуществляет дефрагментацию памяти.

Преимущество динамически распределяемой памяти в том, что она позволяет Вам игнорировать гранулярность выделения памяти и размер страниц и сосредоточиться непосредственно на своей задаче. А недостаток — выделение и освобождение блоков памяти проходит медленнее, чем при использовании других механизмов, и, кроме того, Вы теряете прямой контроль над передачей физической памяти и ее возвратом системе.

Куча — это регион зарезервированного адресного пространства. Первоначально большей его части физическая память не передается. По мере того, как программа занимает эту область под данные, специальный диспетчер, управляющий кучами (heap manager), постранично передаст ей физическую память (из страничного файла). А при освобождении блоков в куче диспетчер возвращает системе соответствующие страницы физической памяти.



## 12 Библиотеки динамической компоновки DLL.

Применение библиотек динамической компоновки на практике подразумевает наличие в них специальных функций, которые могут быть вызваны из других приложений или DLL. Такие функции называются экспортируемыми. Вызывающее приложение определенным образом получает информацию об адресе и характеристиках экспортируемой функции (импортирует функцию), а затем осуществляет собственно ее вызов с передачей соответствующих параметров. Таким образом, приложение получает возможность задействовать все преимущества, которые дает применение библиотек динамической компоновки при разработке программного обеспечения. 

Как правило, типичная DLL содержит некоторое количество внутренних функций, выполняющих реальную работу, а также несколько экспортируемых функций, которые играют роль интерфейса между DLL и приложениями. При этом экспортируемые функции могут вызывать внутренние функции DLL, что, вообще говоря, является хорошей практикой, так как обеспечивает инкапсуляцию и высокую степень внутренней связности в DLL. 

Стандартной точкой входа для DLL, т.е. аналогом WinMain для приложений является функция DllEntryPoint() (еще она может называться DllMain() ).  Она применяется достаточно редко – как правило, в случаях, когда требуется выполнять какие-то инициализационные действия при загрузке DLL, поскольку в этом случае DllEntryPoint() вызывается автоматически. Тем не менее, DllEntryPoint() является обязательным элементом библиотеки DLL, хотя и содержит обычно только оператор выхода. 

Функция GetSomeString() является внутренней функцией DLL и не экспортируется.   Таким образом, другие приложения не имеют прямого доступа к ее коду. В приведенном примере функция GetSomeString() выполняет некоторую полезную работу, т.е. возвращает определенную строку, которая используется вызывающим приложением.

Функция Test() является экспортируемой, т.е. она доступна другим приложениям. Для этого она должна быть описана со специальным модификатором, который   определяется используемой версией компилятора (в приведенном примере   __declspec (dllexport)). При использовании этого модификатора информация о функции будет помещена в таблицу экспорта DLL и станет доступна внешним приложениям. 

Таким образом, после успешной сборки DLL и заполнения таблицы экспорта внешние приложения смогут вызывать функцию Test() и, соответственно,  получать в свое распоряжение строку, возвращаемую функцией GetSomeString(), т.е. задействовать функционал, предоставляемый библиотекой DLL.


## 13 Явное и неявное связывание библиотек динамической компоновки.

Вызов функций из DLL существенно отличается в зависимости от того, применяется неявное или явное связывание библиотеки DLL с приложением. При неявном связывании информация о вызываемой функции и библиотеке DLL, в которой она реализована, помещается в таблицу импорта вызывающего приложения, и оно получает всю необходимую информацию для вызова функции. Это действие выполняется на этапе компоновки приложения с помощью т.н. библиотеки импорта. Такая библиотека создается с помощью   специальной утилиты LIB. Полученная библиотека импорта   содержит сведения о функциях, экспортируемых из DLL. Таким образом, она   является посредником между DLL, которая экспортирует функции, и EXE-файлом, который эти функции использует.  

Поскольку вызываемая из DLL функция является внешней по отношению к вызывающему приложению, она должна обязательно иметь прототип в вызывающей программе, определенный в точном соответствии с его описанием в DLL.   При этом прототип обязательно должен иметь модификатор extern, показывающий, что функция является внешней   по отношению к данному модулю, и ее код следует искать где-то во внешних   модулях (в данном случае в DLL). 

Как видно, приложение содержит прототип функции Test(), совпадающий  с ее описанием в коде библиотеки DLL (за исключением модификатора __declspec (dllexport)), и имеющий модификатор extern. Это дает возможность при компоновке с использованием соответствующей библиотеки импорта напрямую осуществлять вызов функции DLL, неявно связанной с приложением, как показано в коде функции WinMain(). 

Данная схема вызова удобна тем, что не требует от программиста никаких дополнительных усилий для связи с DLL и вызова нужной функции. 

При явном связывании вызов функции осуществляется иначе и требует от программиста следующих явных действий:  
* загрузка DLL (через LoadLibrary()) 
* получение адреса нужной функции (через GetProcAddress()) 
* выгрузка DLL (через FreeLibrary())  

Как видно, вызов функции при явном связывании осуществляется значительно сложнее и требует, в частности, иного описания функции в самой библиотеке DLL.  

Наличие в описании модификатора extern “C” продиктовано особенностями явного связывания, согласно которым вызывающей программе   должно быть известно внутреннее имя функции в DLL. Дело в том, что компиляторы С++ используют   т.н. расширение имен (name mangling), предназначенное для поддержки   перегруженных функций. При расширении имен внутреннее имя функции отличается   от имени в тексте программы, поскольку к нему дописываются специальные   символы расширения. Таким образом, попытка вызвать функцию из DLL по имени   будет неудачной (имя функции, переданное вызывающим приложением, и внутреннее имя функции будут отличаться). Один из способов обхода данной проблемы – это отключение расширения имен, которое достигается с использованием специального модификатора extern “C”. В этом случае внутреннее имя функции будет совпадать с именем функции в коде вызывающего приложения. 

Вызывающее приложение определяет указатель на функцию, имеющую тот же тип, что и функция Test(), которая в этом примере вызывается из DLL. Это необходимо, так как вызов функции при явном связывании происходит по ее указателю. Для удобства дальнейшего использования создается тип такого указателя, имеющий имя PFN. 

Для вызова функции Test() из DLL вызывающее приложение вначале должно загрузить библиотеку DLL, содержащую эту функцию, в адресное пространство процесса, что осуществляется посредством функции WinAPI LoadLibrary() как показано в приведенном примере. При этом в переменной hMod сохраняется дескриптор модуля DLL, загруженной в адресное пространство процесса.  

Далее посредством вызова функции WinAPI GetProcAddress() выполняется получение адреса функции Test() внутри модуля DLL, ранее загруженной в процесс вызывающего приложения. Полученный адрес приводится к ранее определенному типу PFN. Так как теперь известен адрес функции Test(), то выполняется ее фактический вызов, в результате которого в переменную str возвращается строка, представляющая собой результат выполнения функций из библиотеки DLL. Данная строка выводится в MessageBox, на чем использование функционала DLL приложением и завершается. Так как теперь ранее загруженная DLL более не требуется, то происходит ее выгрузка из адресного пространства процесса вызывающего приложения посредством функции WinAPI FreeLibrary(), после чего вызывающее приложение завершает работу.                               Следует особо отметить, что явное связывание при больших усилиях, связанных с вызовом функций из DLL, обеспечивает значительную гибкость и лучший контроль со стороны программиста, чем неявное связывание.   

## 14 Организация дискового пространства.

Жесткий диск (НDD — Hard Disk Drive) устроен следующим образом: на шпинделе, соединенным с электромотором, расположен блок из нескольких дисков (блинов), над поверхностью которых находятся головки для чтения/записи информации. Форма головкам придается в виде крыла и крепятся они на серпообразный поводок. При работе они «летят» над поверхностью дисков в воздушном потоке, который создается при вращении этих же дисков. Диск разбит на дорожки (или треки), которые в свою очередь поделены на сектора. Две дорожки, равноудаленные от центра, но расположенные по разные стороны диска, называются цилиндрами.

Все пространство диска разбивается на дорожки в виде концентрических окружностей, которые в свою очередь разделяются на секторы. Для их создания используется специальная процедура, которая называется форматированием и выполняется с помощью средств операционной системы (например, в MS DOS это команда FORMAT). Фактически при этом осуществляются две различные операции, называемые форматированием низкого и высокого уровней. Низкоуровневое (физическое) форматирование состоит в нанесении на диск электронных меток для обозначения дорожек и секторов. При форматировании высокого уровня (его называют также логическим) осуществляется создание служебных областей на диске.

Перед использованием магнитный диск обязательно должен быть отформатирован. Программа форматирования проверяет также работоспособность диска, отсутствие ошибок при записи и считывании информации. Дефектные секторы специальным образом помечаются и в дальнейшем не используются. Если диск уже форматировался ранее и на нем записана какая-то информация, то повторная процедура форматирования полностью уничтожает ее.

В первом физическом секторе жесткого диска располагается главная загрузочная запись (master boot record, MBR) и таблица разделов диска. MBR при загрузке с жесткого диска считывает и загружает в память первый физический сектор на активном разделе диска, называемый загрузочным сектором (boot sector). Каждая запись в таблице разделов (partition table) содержит начальную позицию и размер каждого раздела на жестком диске, а также информацию о том, первый сектор какого раздела содержит загрузочную запись.

Базовой единицей физического сектора жесткого диска является раздел, создаваемый во время разметки жесткого диска и обслуживаемый какой-либо файловой системой. Некоторые операционные системы поддерживают создание томов, охватывающих несколько разделов.

Жесткий диск может содержать до четырех основных разделов. Это ограничение связано с характером организации данных на жестких дисках IBM-совместимых компьютеров. Многие операционные системы позволяют создавать так называемый расширенный (extended) раздел, который по аналогии с основным разделом может разбиваться на несколько логических дисков.



