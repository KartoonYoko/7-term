## 1 Назначение и классификация операционных систем.
ОС - специализированная прграмма (комплекс программ), предназначенная для эффективного использования всех ресурсов вычислительной системы и обеспечения работоспособности дргуих программ.

Основные функции ОС
- Управление апаратными ресурсами вычислительными системами (абстрация над вычислительной системой для легкого её использования)
- Создание среды для выполнения программ
- Обеспечение интерфейса для взаимодействия с пользователем

ОС поддерживает два режима:
- режим ядра 
- режим пользователя

Классификация ОС по приминению на различном ПО:
- ОС мейнфреймов и суперкомпьютеров
- Серверные ОС
- Многопроцессорные ОС
- ОС персональных компьютеров
- ОС моблиьных устройств
- ОС реального времени

Классификация по типу ядра:
- Монолитное - все функции внутри ядра, но тяжело расширять
- Модульное - разновидность микроялро, пример драйверы
- Микроядро - содержитт только необходимые функции, но надежность меньше и быстродействие
- Наноядро
- Экзоядро
- Гибридное ядро

## 2 Понятие WinAPI и его применение при разработке прикладных программ.

**Кратко: API (интерфейс прикладного программирования) упрощает процесс программирования при создании приложений, абстрагируя базовую реализацию и предоставляя только объекты или действия, необходимые разработчику. Windows API предназначен для создания программистами прикладных программ, т.к. система без возможности разрабатывать под нее приложения скорее всего бесполезна. Иначе бы пришлось самим рисовать формочки, читать с жесткого диска и прочее. Называтся он программным интерфейсом, потому что реализует контракт программирования (как что использовать, что вызывать).**

## 3 Процессы и потоки.
Процесс — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память)  
Характеристики процесса
- Представляет отдельный экземпляр исполняющей программы
- Явдяется контейнером для всех ресурсов, относящихся к исполняемой программе (потоки, адресное пространство, дескрипторы)
- Позволяет операционной системе управлять выполнением программы (завершать, выделять ресурсы, изменять приоритеты, обеспечивать изоляцию и защиту)

Варианты **создания** процессов
- Инициализация системы
- Выполнение работающим процессом системного вызова, предназначенного для создания другого процесса
- Запрос пользователя на создание новго процесса
- Инициация пакетного задания

Как могу **завершаться** процессы
- Обычный выход (добровольно)
- Выход при возникновении ошибки (добровольно)
- Возникновение фатальной ошибки (принудительно)
- Уничтожение другим процессом (принудительно)

**Структуры** управления процессом
- Таблица процессов. Одна запись на каждый процесс.
- Блок управления процессом. Process control block (PCB). Описывает свой процесс и его текущее состояние.
- Образ процесса. Process Image. Память выделённая для процесса. То, как программа представлена в **виртуальном адресном пространстве**.

Создание процесса в Windows:
- ОС создает соответсвующие служебные объекты, с помощью которых управляют процессом (объект процесса, объект первичный поток)
    1. Преобразование и проверка приемлимости параметров и флагов
    2. Открытие exe файла и создание объекта раздела
    3. Создание процесса Windows
    4. Создание объекта потока Windows
- Инициализация подсистемы Windows
    5. Выполнение инициализации характерного для подсистемы Windows процесса, запускается после создания данного процесса
    6. Исходный процесс возвращает выполнение исходному коду
- Новый процесс
    7. Заключительная часть инициализации новго процесса и образа
    8. Начало выполнения с точки входа в образ

Создание процесса в Unix
- Родительский PCB создает дочерний PCB копируя себя полностью, кроме PID (адресное пространство дочернего процесса сперва даже хранит код родительского)

**Поток**
Для каждого процесса операционная система создает один главный поток (thread ), который является потоком выполняющихся по очереди команд центрального процессора. При необходимости главный поток может создавать другие потоки, пользуясь для этого программным интерфейсом операционной системы.

## 4 Планирование в системах с одним процессором.

**Планирование** - обеспечение поочередного доступа процессов к одному процессору.

**Планировщик** - отвечающая за это часть операционной системы.

**Алгоритм планирования** - используемый алгоритм для планирования.

Задача планирования процессов состоит из трех действий:

* Определение момента времени для смены, выполняемого в данный момент, процесса.
* Выбор того процесса из очереди готовности, которому будет передано управление.
* Переключение контекста (переключение между процессами).

## 5 Планирование в многопроцессорных системах.

На однопроцессорной машине планирование одномерно. Единственный вопрос, на который должен быть каждый раз получен ответ, – какой процесс должен быть запущен следующим? На мультипроцессоре планирование двумерно. Планировщик должен решить, какой процесс и на котором центральном процессоре запустить. Это дополнительное измерение существенно усложняет планирование процессов на многопроцессорных машинах. Другой усложняющий фактор состоит в том, что в ряде случаев все процессы являются независимыми, тогда как в других случаях они формируют группы.

### Планирование
* Ведение списка или множества списков для разных приоритетов. Освобождающиеся процессоры выбирают процессы из списка по очереди.
* «умное планирование». Если процесс входит в критическую область, захватывается мьютекс, то он не останавливается по кванту времени, а выполняется до освобождения мьютекса.
* Родственное планирование. По возможности процессы отправляются на обработку к тому процессору, который обрабатывал их до этого.
* Планирование по модели «производитель-потребитель».

## 6 Переключение потоков и краткосрочное планирование.

Планировщик хранит очередь исполняемых потоков для каждого уровня приоритета. Такие потоки называются **готовыми к исполнению (ready threads)**. Когда процессор становится доступным - система выполняет переключение потоков. Шаги в переключении следующие:
1. Сохранить контекст только что завершившегося потока.
2. Поместить только завершившийся поток в конец очереди его приоритета.
3. Найти наивысший приоритет в очереди исполняемых потоков
4. Удалить поток из наччала очереди, загрузить его контекст и выполнить его.

Приостановленные и заблокированные потоки не являются готовыми к исполнению.

Наиболее распространненные причины переключения контекста:
- Срез времени, отведенный потоку, истек.
- Поток с более высоким приоритетом стал готовым к исполнению.
- Работающий поток ждёт и ему не нужно процессорное время. (Когда работающему потоку нужно подождать, он отказывается от оставшейся части своего временного интервала.)

Планирование использования процессора применяется в качестве **краткосрочного планирования процессов**. Выбор нового процесса для исполнения оказывает влияние на функционирование системы до наступления очередного аналогичного события, т. е. в течение короткого промежутка времени, чем и обусловлено название этого уровня планирования – краткосрочное.

**Краткосрочное планирование** также известно как планировщик ЦП . Основная цель этого планировщика — повысить производительность системы в соответствии с установленными критериями. Это поможет вам выбрать из группы процессов, которые готовы к выполнению, и выделит ЦП одному из них. Диспетчер передает управление процессором процессу, выбранному краткосрочным планировщиком.
[Источник краткосрочного планировщика, можно найти инфу по дргуим](https://coderlessons.com/tutorials/akademicheskii/osnovy-operatsionnykh-sistem/24-planirovanie-protsessa)

Чтобы переключить потоки, нужно сменить контекст потока и т.д.

Переключение контекста (англ. context switch) - это процесс записи и восстановления состояния процесса или потока таким образом, чтобы в дальнейшем продолжить его выполнение с прерванного места. Этот механизм позволяет нескольким процессам разделить между собой ресурсы одного центрального процессора. Является особенностью многозадачных ОС.

## 7 Приоритеты процессов и потоков.

Потоки планируются для запуска на основе их приоритета планирования. Каждому потоку назначается приоритет планирования. Уровни приоритета находятся в диапазоне от нуля (самый низкий приоритет) до 31 (наивысший приоритет). Только поток нулевой страницы может иметь приоритет, равный нулю. (Поток нулевой страницы — это системный поток, ответственный за обнуление свободных страниц при отсутствии других потоков, которые необходимо выполнить.)

Система рассматривает все потоки с одинаковым приоритетом, равным. Система назначает временные срезы циклическим перебору для всех потоков с наивысшим приоритетом. Если ни один из этих потоков не готов к выполнению, система назначает временные срезы циклическим перебору для всех потоков со следующим высшим приоритетом. Если поток с более высоким приоритетом станет доступным для выполнения, система прекратит выполнение потока с низким приоритетом (не позволяя ему завершить работу с его временным срезом) и назначает полный временной срез для потока с более высоким приоритетом.

Приоритет каждого потока определяется следующими критериями.
- Класс приоритета его процесса
- Уровень приоритета потока в классе приоритета его процесса

Класс приоритета и уровень приоритета объединяются для формирования базового приоритета потока.

Классы приоритетов процессов:
- IDLE_PRIORITY_CLASS
- BELOW_NORMAL_PRIORITY_CLASS
- NORMAL_PRIORITY_CLASS
- ABOVE_NORMAL_PRIORITY_CLASS
- HIGH_PRIORITY_CLASS
- REALTIME_PRIORITY_CLASS

Уровни приоритета потоков:
- THREAD_PRIORITY_IDLE
- THREAD_PRIORITY_LOWEST
- THREAD_PRIORITY_BELOW_NORMAL
- THREAD_PRIORITY_NORMAL
- THREAD_PRIORITY_ABOVE_NORMAL
- THREAD_PRIORITY_HIGHEST
- THREAD_PRIORITY_TIME_CRITICAL

Использование класса HIGH_PRIORITY_CLASS ограничено процессами, которые должны завершаться за короткое время, чтобы не вызвать сбойной ситуации.

Большинство процессов запускается в рамках класса с нормальным приоритетом. Нормальный приоритет означает, что процесс не требует какого-либо специального внимания со стороны операционной системы.

И наконец, процессы с фоновым приоритетом запускаются лишь в том случае, если в очереди Диспетчера задач нет других процессов. Обычные виды приложений, использующие такой приоритет, — это программы сохранения экрана и системные агенты

## 8 Синхронизация, механизмы синхронизации.

Синхронизация процессов — это механизм, позволяющий обеспечить целостность какого-либо ресурса (файл, данные в памяти), когда он используется несколькими процессами или потоками в случайном порядке. Для синхронизации процессов и потоков используются семафоры, мьютексы и критические секции. 

**Критическая секция** - участок исполняемого кода программы, в котором производится доступ к общему ресурсу (данным или устройству), который не должен быть одновременно использован более чем одним потоком выполнения.
**Взаимное исключение** - блокировка критической секции, когда он занята уже одним потоком.

**Семафо́р** — примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить две атомарные операции: увеличение и уменьшение значения на единицу, при этом операция уменьшения для нулевого значения счётчика является блокирующейся (То есть семафор допускает процесс в критичискую секцию после чего уменьшает счетчик, соотвественно на нуле блокирует доступ в критическую секцию).

**Мьютекс** - реализует взаимное исключение. Его основная задача - блокировать все потоки, которые пытаются получить доступ к коду, когда этот код уже выполняет некоторый поток.


## 9 Виртуальное адресное пространство процесса.

Для каждого процесса создается изолированное виртуальное адресное пространство. ОС загружает **образ (см. билет 3, струткура процесса)** программы в виртуальное адресное пространство.

Адресное пространство для каждого процесса является закрытым и не может быть доступно другим процессам, если он не является общим.

Виртуальный адрес не представляет фактическое физическое расположение объекта в памяти; Вместо этого система ведет таблицу страниц для каждого процесса, который представляет собой внутреннюю структуру данных, используемую для преобразования виртуальных адресов в соответствующие физические адреса. Каждый раз, когда поток ссылается на адрес, система преобразует виртуальный адрес в физический адрес.

Рабочий набор процесса — это набор страниц в виртуальном адресном пространстве процесса, которые в настоящий момент находятся в физической памяти. Если несколько процессов совместно используют одну страницу, удаление страницы из рабочего набора одного процесса не влияет на другие процессы.

## 10 Страничная адресация и работа файла подкачки.

Страничная адресация памяти представляет собой механизм управления памятью, позволяющий разрешить задачу повышения эффективности процессов обмена информацией между уровнями иерархической памяти.

Основная идея страничной адресации состоит в разбиении всей памяти на блоки одинаковой длины, называемые страницами. Размер страниц обычно равен целой степени 2 (например, 4K или 1M).

Линейный адрес может не совпадать с физическим адресом, эту страничную трансляцию выполняет **блок управления памятью**. Блок управления памятью использует **таблицу страниц**, в которой хранится соотношение виртуальных страниц к блокам физической памяти. Для обращение к области памяти используется два числа: номер страницы и отступ внутри страницы.

Преимущества:
* При этом для программиста память остается линейной, хотя линейные адреса могут быть разбросаны по разным физическим адресам.
* Легче избавиться от фрагментации памяти.
* Виртуальная память дешевая, можно выделять гигабайты памяти, однако пока они не используются, реальной взаимосвязи с физической памяти нет. Т.е. резервирование не связывает с физическими страницами.
* Страничная трансляция не совпадает с физическими, поэтому программы изолированы друг от друга. (хотя есть исключение CopyOnWrite)
* OS в том числе защищает саму себя.

**Файл подкачки**
Оперативная память — это ограниченный ресурс, в то время как для большинства практических целей виртуальная память не ограничена. Может быть много процессов, и каждый процесс имеет свои собственные 2 ГБ частного виртуального адресного пространства. Если память, используемая всеми существующими процессами, превышает доступную оперативную память, операционная система перемещает страницы (4-КБ частей) одного или более виртуальных адресных пространств на жесткий диск компьютера. Это освободит раму оперативной памяти для других применений. В Windows системах указанные страницы хранятся в одном или Pagefile.sys файлах в корне раздела. В каждом разделе диска может быть один такой файл

## 11 Управление памятью в системах Windows (динамическая память).

Динамическое распределение памяти — способ выделения оперативной памяти компьютера для объектов в программе, при котором выделение памяти под объект осуществляется во время выполнения программы.

При динамическом распределении памяти объекты размещаются в т. н. «куче» (англ. heap): при конструировании объекта указывается размер запрашиваемой под объект памяти, и, в случае успеха, выделенная область памяти, условно говоря, «изымается» из «кучи», становясь недоступной при последующих операциях выделения памяти. Противоположная по смыслу операция — освобождение занятой ранее под какой-либо объект памяти: освобождаемая память, также условно говоря, возвращается в «кучу» и становится доступной при дальнейших операциях выделения памяти.

По мере создания в программе новых объектов количество доступной памяти уменьшается. Отсюда вытекает необходимость постоянно освобождать ранее выделенную память. В идеальной ситуации программа должна полностью освободить всю память, которая потребовалась для работы. По аналогии с этим, каждая подпрограмма (процедура или функция) должна обеспечить освобождение всей памяти, выделенной в ходе её выполнения. Неправильное управление памятью приводит к т.н. «утечкам» памяти, когда выделенная память не освобождается. Многократные утечки памяти могут привести к исчерпанию всей оперативной памяти и нарушить работу операционной системы.

Другая проблема — это проблема фрагментации памяти. Выделение памяти происходит блоками — непрерывными фрагментами оперативной памяти (таким образом, каждый блок — это несколько идущих подряд байт). В какой-то момент в куче попросту может не оказаться блока подходящего размера и, даже если свободная память достаточна для размещения объекта, операция выделения памяти окончится неудачей.

Для управления динамическим распределением памяти используется «сборщик мусора» — программный объект, который следит за выделением памяти и обеспечивает её своевременное освобождение. Сборщик мусора также следит за тем, чтобы свободные блоки имели максимальный размер, и, при необходимости, осуществляет дефрагментацию памяти.

Преимущество динамически распределяемой памяти в том, что она позволяет Вам игнорировать гранулярность выделения памяти и размер страниц и сосредоточиться непосредственно на своей задаче. А недостаток — выделение и освобождение блоков памяти проходит медленнее, чем при использовании других механизмов, и, кроме того, Вы теряете прямой контроль над передачей физической памяти и ее возвратом системе.

Куча — это регион зарезервированного адресного пространства. Первоначально большей его части физическая память не передается. По мере того, как программа занимает эту область под данные, специальный диспетчер, управляющий кучами (heap manager), постранично передаст ей физическую память (из страничного файла). А при освобождении блоков в куче диспетчер возвращает системе соответствующие страницы физической памяти.

## 12 Библиотеки динамической компоновки DLL.

Применение библиотек динамической компоновки на практике подразумевает наличие в них специальных функций, которые могут быть вызваны из других приложений или DLL. Такие функции называются экспортируемыми. Вызывающее приложение определенным образом получает информацию об адресе и характеристиках экспортируемой функции (импортирует функцию), а затем осуществляет собственно ее вызов с передачей соответствующих параметров. Таким образом, приложение получает возможность задействовать все преимущества, которые дает применение библиотек динамической компоновки при разработке программного обеспечения. 

Как правило, типичная DLL содержит некоторое количество внутренних функций, выполняющих реальную работу, а также несколько экспортируемых функций, которые играют роль интерфейса между DLL и приложениями. При этом экспортируемые функции могут вызывать внутренние функции DLL, что, вообще говоря, является хорошей практикой, так как обеспечивает инкапсуляцию и высокую степень внутренней связности в DLL. 

Стандартной точкой входа для DLL, т.е. аналогом WinMain для приложений является функция DllEntryPoint() (еще она может называться DllMain() ).  Она применяется достаточно редко – как правило, в случаях, когда требуется выполнять какие-то инициализационные действия при загрузке DLL, поскольку в этом случае DllEntryPoint() вызывается автоматически. Тем не менее, DllEntryPoint() является обязательным элементом библиотеки DLL, хотя и содержит обычно только оператор выхода. 

Экспортируемая функция должна быть описана со специальным модификатором, который   определяется используемой версией компилятора (в приведенном примере   __declspec (dllexport)). При использовании этого модификатора информация о функции будет помещена в таблицу экспорта DLL и станет доступна внешним приложениям. 

Таким образом, после успешной сборки DLL и заполнения таблицы экспорта внешние приложения смогут вызывать функцию Test() и, соответственно,  получать в свое распоряжение строку, возвращаемую функцией GetSomeString(), т.е. задействовать функционал, предоставляемый библиотекой DLL.

## 13 Явное и неявное связывание библиотек динамической компоновки.

Вызов функций из DLL существенно отличается в зависимости от того, применяется неявное или явное связывание библиотеки DLL с приложением. При неявном связывании информация о вызываемой функции и библиотеке DLL, в которой она реализована, помещается в таблицу импорта вызывающего приложения, и оно получает всю необходимую информацию для вызова функции. Это действие выполняется на этапе компоновки приложения с помощью т.н. библиотеки импорта. Такая библиотека создается с помощью   специальной утилиты LIB. Полученная библиотека импорта   содержит сведения о функциях, экспортируемых из DLL. Таким образом, она   является посредником между DLL, которая экспортирует функции, и EXE-файлом, который эти функции использует.  

Поскольку вызываемая из DLL функция является внешней по отношению к вызывающему приложению, она должна обязательно иметь прототип в вызывающей программе, определенный в точном соответствии с его описанием в DLL.   При этом прототип обязательно должен иметь модификатор extern, показывающий, что функция является внешней   по отношению к данному модулю, и ее код следует искать где-то во внешних   модулях (в данном случае в DLL). 

Как видно, приложение содержит прототип функции Test(), совпадающий  с ее описанием в коде библиотеки DLL (за исключением модификатора __declspec (dllexport)), и имеющий модификатор extern. Это дает возможность при компоновке с использованием соответствующей библиотеки импорта напрямую осуществлять вызов функции DLL, неявно связанной с приложением, как показано в коде функции WinMain(). 

Данная схема вызова удобна тем, что не требует от программиста никаких дополнительных усилий для связи с DLL и вызова нужной функции. 

При явном связывании вызов функции осуществляется иначе и требует от программиста следующих явных действий:  
* загрузка DLL (через LoadLibrary()) 
* получение адреса нужной функции (через GetProcAddress()) 
* выгрузка DLL (через FreeLibrary())  

Как видно, вызов функции при явном связывании осуществляется значительно сложнее и требует, в частности, иного описания функции в самой библиотеке DLL.  

Наличие в описании модификатора extern “C” продиктовано особенностями явного связывания, согласно которым вызывающей программе   должно быть известно внутреннее имя функции в DLL. Дело в том, что компиляторы С++ используют   т.н. расширение имен (name mangling), предназначенное для поддержки   перегруженных функций. При расширении имен внутреннее имя функции отличается   от имени в тексте программы, поскольку к нему дописываются специальные   символы расширения. Таким образом, попытка вызвать функцию из DLL по имени   будет неудачной (имя функции, переданное вызывающим приложением, и внутреннее имя функции будут отличаться). Один из способов обхода данной проблемы – это отключение расширения имен, которое достигается с использованием специального модификатора extern “C”. В этом случае внутреннее имя функции будет совпадать с именем функции в коде вызывающего приложения. 

Вызывающее приложение определяет указатель на функцию, имеющую тот же тип, что и функция Test(), которая в этом примере вызывается из DLL. Это необходимо, так как вызов функции при явном связывании происходит по ее указателю. Для удобства дальнейшего использования создается тип такого указателя, имеющий имя PFN. 

Для вызова функции Test() из DLL вызывающее приложение вначале должно загрузить библиотеку DLL, содержащую эту функцию, в адресное пространство процесса, что осуществляется посредством функции WinAPI LoadLibrary() как показано в приведенном примере. При этом в переменной hMod сохраняется дескриптор модуля DLL, загруженной в адресное пространство процесса.  

Далее посредством вызова функции WinAPI GetProcAddress() выполняется получение адреса функции Test() внутри модуля DLL, ранее загруженной в процесс вызывающего приложения. Полученный адрес приводится к ранее определенному типу PFN. Так как теперь известен адрес функции Test(), то выполняется ее фактический вызов, в результате которого в переменную str возвращается строка, представляющая собой результат выполнения функций из библиотеки DLL. Данная строка выводится в MessageBox, на чем использование функционала DLL приложением и завершается. Так как теперь ранее загруженная DLL более не требуется, то происходит ее выгрузка из адресного пространства процесса вызывающего приложения посредством функции WinAPI FreeLibrary(), после чего вызывающее приложение завершает работу.                               Следует особо отметить, что явное связывание при больших усилиях, связанных с вызовом функций из DLL, обеспечивает значительную гибкость и лучший контроль со стороны программиста, чем неявное связывание.   

## 14 Организация дискового пространства.

Жесткий диск (НDD — Hard Disk Drive) устроен следующим образом: на шпинделе, соединенным с электромотором, расположен блок из нескольких дисков (блинов), над поверхностью которых находятся головки для чтения/записи информации. Форма головкам придается в виде крыла и крепятся они на серпообразный поводок. При работе они «летят» над поверхностью дисков в воздушном потоке, который создается при вращении этих же дисков. Диск разбит на дорожки (или треки), которые в свою очередь поделены на сектора. Две дорожки, равноудаленные от центра, но расположенные по разные стороны диска, называются цилиндрами.

Все пространство диска разбивается на дорожки в виде концентрических окружностей, которые в свою очередь разделяются на секторы. Для их создания используется специальная процедура, которая называется форматированием и выполняется с помощью средств операционной системы (например, в MS DOS это команда FORMAT). Фактически при этом осуществляются две различные операции, называемые форматированием низкого и высокого уровней. Низкоуровневое (физическое) форматирование состоит в нанесении на диск электронных меток для обозначения дорожек и секторов. При форматировании высокого уровня (его называют также логическим) осуществляется создание служебных областей на диске.

Перед использованием магнитный диск обязательно должен быть отформатирован. Программа форматирования проверяет также работоспособность диска, отсутствие ошибок при записи и считывании информации. Дефектные секторы специальным образом помечаются и в дальнейшем не используются. Если диск уже форматировался ранее и на нем записана какая-то информация, то повторная процедура форматирования полностью уничтожает ее.

В первом физическом секторе жесткого диска располагается главная загрузочная запись (master boot record, MBR) и таблица разделов диска. MBR при загрузке с жесткого диска считывает и загружает в память первый физический сектор на активном разделе диска, называемый загрузочным сектором (boot sector). Каждая запись в таблице разделов (partition table) содержит начальную позицию и размер каждого раздела на жестком диске, а также информацию о том, первый сектор какого раздела содержит загрузочную запись.

Базовой единицей физического сектора жесткого диска является раздел, создаваемый во время разметки жесткого диска и обслуживаемый какой-либо файловой системой. Некоторые операционные системы поддерживают создание томов, охватывающих несколько разделов.

Жесткий диск может содержать до четырех основных разделов. Это ограничение связано с характером организации данных на жестких дисках IBM-совместимых компьютеров. Многие операционные системы позволяют создавать так называемый расширенный (extended) раздел, который по аналогии с основным разделом может разбиваться на несколько логических дисков.



## 15.Организация файловой системы FAT32.
В файловой системе FAT смежные секторы диска объединяются в единицы, называемые кластерами. Количество секторов в кластере равно степени двойки (см. далее). Для хранения данных файла отводится целое число кластеров (минимум один), так что, например, если размер файла составляет 40 байт, а размер кластера 4 Кбайт, реально занят информацией файла будет лишь 1 % отведённого для него места. Во избежание подобных ситуаций целесообразно уменьшать размер кластеров, а для сокращения объёма адресной информации и повышения скорости файловых операций — наоборот. На практике выбирают некоторый компромисс. Так как ёмкость диска вполне может и не выражаться целым числом кластеров, обычно в конце тома присутствуют так называемые surplus sectors — «остаток» размером менее кластера, который не может отводиться ОС для хранения информации.
Пространство тома FAT32 логически разделено на три смежные области:  
-	Зарезервированная область. Содержит служебные структуры, которые принадлежат загрузочной записи раздела (Partition Boot Record — PBR, для отличия от Master Boot Record — главной загрузочной записи диска; также PBR часто некорректно называется загрузочным сектором) и используются при инициализации тома;
-	Область таблицы FAT, содержащая массив индексных указателей («ячеек»), соответствующих кластерам области данных. Для повышения надёжности на диске обычно представлено две копии таблицы FAT;
-	Область данных, где записано собственно содержимое файлов — то есть текст текстовых файлов, кодированное изображение для файлов рисунков, оцифрованный звук для аудиофайлов и т. д.

FAT 32 - усовершенствованная версия системы VFAT, поддерживающая жесткие диски объемом более 32 Гб. Впервые она была включена в состав ОС Windows 95 OSR 2 и поддерживается во всех последующих версиях Windows. В FAT32 были расширены атрибуты файлов, стало возможным хранить время и дату создания, модификации и последнего доступа к файлу или каталогу.
Из-за требования совместимости с ранее созданными программами структура FAT32 практически не изменилась. Главные отличия от предыдущих версий FAT состоят в следующем:
-	блок начальной загрузки на разделах с FAT32 был увеличен до 2 секторов; он включает резервную копию загрузочного сектора, что делает систему быть более устойчивой к возможным сбоям на диске;
-	объем, занимаемый таблицей размещения файлов, увеличился, поскольку теперь каждая запись в ней занимает 32 байта, и общее число кластеров на разделе FAT32 больше, чем на разделах FAT. Соответственно, выросло и количество секторов, отводимых под размещение служебной информации;
-	корневой каталог в FAT32 больше не располагается в определенном месте; теперь на этом месте хранится указатель на начальный кластер корневого каталога. В результате снимается ранее существовавшее ограничение на число записей в корневом каталоге;
-	для учета свободных кластеров в зарезервированной области на разделе FAT32 имеется сектор, содержащий число свободных кластеров и номер самого последнего использованного кластера. Это позволяет следующего кластера не перечитывать заново всю таблицу размещения файлов.

## 16.Организация файловой системы NTFS.
Файловая система NTFS (New Technology File System) была специально разработана для ОС Windows NT. В ней значительно расширены возможности по управлению доступом к отдельным файлам и каталогам, введено большое число атрибутов, реализованы отказоустойчивость и средства динамического сжатия файлов. NTFS допускает имена файлов длиной до 255 символов, при этом она использует тот же алгоритм для генерации короткого имени, что и VFAT. NTFS обладает возможностью самостоятельного восстановления в случае сбоя ОС или оборудования, так что дисковый том остается доступным, а структура каталогов не нарушается.

Каждый файл на разделе NTFS представлен записью в специальном файле MFT (Master File Table, главная файловая таблица). NTFS резервирует около 1 Мб для размещения первых 16 записей служебной информации. 17-я и последующие записи MFT используются собственно файлами и каталогами. Первая запись содержит саму главную файловую таблицу. За ней следует зеркальная запись MFT. Если первая запись MFT разрушена, NTFS считывает вторую запись, чтобы отыскать зеркальный файл MFT. Местоположение сегментов данных MFT и зеркального файла MFT хранится в секторе начальной загрузки. Копия сектора начальной загрузки находится в логическом центре диска. Третья запись MFT содержит файл регистрации, применяемый для восстановления файлов.
NTFS была разработана как восстанавливаемая файловая система, использующая модель обработки транзакций. Каждая операция ввода-вывода, изменяющая файл на томе NTFS, рассматривается системой как транзакция. При модификации любого файла пользователем, в файле регистрации фиксируется вся информация, необходимая для повторения или «отката» транзакции. Если транзакция завершена успешно, производится модификация файла; в противном случае NTFS оставляет его неизменным. В журнале транзакций (log file) регистрируются все операции, влияющие на структуру тома, включая создание файлов и любые команды, изменяющие структуру каталогов.

Схема распределения пространства на томе хранится в файле битовой карты (bitmap file). Атрибут данных этого файла содержит карту, каждый бит которой представляет один кластер тома и указывает, свободен ли данный кластер или занят некоторым файлом.
В загрузочном файле (boot file) хранится код начального загрузчика операционной системы.
NTFS также поддерживает файл плохих кластеров (bad cluster file) для регистрации поврежденных участков на томе и файл тома (volume file), содержащий имя тома, версию NTFS и бит, который устанавливается при повреждении тома. Наконец, имеется файл, содержащий таблицу определения атрибутов (attribute definition table), которая задает типы атрибутов, поддерживаемые на томе, и указывает, можно ли их индексировать, восстанавливать операцией восстановления системы и т.д.

NTFS распределяет пространство кластерами и использует для их нумерации 64 разряда, что дает возможность иметь на каждом томе 2й4 кластеров, каждый размером до 64 Кбайт. Как и в FAT, размер кластера может меняться, но он не обязательно возрастает пропорционально раз размеру диска.
NTFS позволяет сохранять файлы размером до 16 эксабайт (2м байт) и располагает встроенными средствами уплотнения файлов в реальном времени. Сжатие является одним из атрибутов файла или каталога, и подобно любому атрибуту может быть снято или установлено в любой момент (сжатие возможно на разделах с размером кластера не более 4 Кб). При этом (в отличие от схем уплотнения, используемых в FAT) применяется пофайловое уплотнение; таким образом, порча небольшого участка диска не приводит к потере информации в других файлах. Для уменьшения фрагментации NTFS всегда пытается сохранять файлы в непрерывных блоках.

Каталог в NTFS представляет собой специфический файл, хранящий ссылки на другие файлы и каталоги; тем самым обеспечивается иерархическое строение данных на диске. Файл каталога поделен на блоки, каждый из которых содержит имя файла, базовые атрибуты и ссылку на элемент MFT, который предоставляет полную информацию об элементе каталога. Внутренняя структура каталога NTFS представляет собой бинарное дерево. Если в линейном каталоге (например, во всех версиях FAT) для поиска файла с данным именем операционной системе приходится просматривать все его элементы, то в бинарном дереве имена файлов располагаются таким образом, чтобы поиск осуществлялся максимально быстро. Например, для поиска одного файла среди 1000 в FAT придется осуществить в среднем 500 сравнений (наиболее вероятно, что файл будет найден где-то в середине списка), а системе NTFS - всего около 10.

Начиная с ОС Windows 2000, Microsoft использует новую версию данной файловой системы - NTFS 5.O. В ней были введены дополнительные атрибуты файлов; наряду с правом доступа появилось понятие запрета доступа (что позволяет, например, при наследовании пользователем прав группы на какой-нибудь файл, запретить ему возможность изменять его содержимое). Новая система также позволяет вводить ограничения (квоты) на размер дискового пространства, предоставляемого пользователям и проецировать любой каталог (как на локальном, так и на удаленном компьютере) в подкаталог на локальном диске.

